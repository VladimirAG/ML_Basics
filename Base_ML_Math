{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "id": "8R3RBMyxzyp0",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-3a9d1fb3",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Запустите эту ячейку для первоначальной настройки\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "np.random.seed(21)\n",
    "plt.style.use('fivethirtyeight')\n",
    "plt.rc('lines', linewidth=2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "9L7Rrqpzzyp1",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-bc02cf6bf1ffde",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "# Домашнее задание 1. Основные термины в машинном обучении. Базовая математика в машинном обучении"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "zYGiIuLVeO-F"
   },
   "source": [
    "# Часть 1. Векторы и основы работы в NumPy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "6L_wWqzhzyp2",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-b40bdcf9629b9",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 1**\n",
    "\n",
    "Напишите код функции для вычисления L2-нормы одномерного np.array вектора с помощью NumPy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "sM9kPY6tzyp2",
    "nbgrader": {
     "grade": false,
     "grade_id": "l2_norm",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def l2_norm(vector):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    return np.linalg.norm(vector)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "id": "742ddJ3Tzyp3",
    "nbgrader": {
     "grade": true,
     "grade_id": "l2_norm_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Тест 1: вектор (1, 0, 0) имеет L2-норму 1.\n",
    "vector1 = np.array([1, 0, 0])\n",
    "assert l2_norm(vector1) == 1.0\n",
    "\n",
    "# Тест 2: вектор (0, 1, 0) имеет L2-норму 1.\n",
    "vector2 = np.array([0, 1, 0])\n",
    "assert l2_norm(vector2) == 1.0\n",
    "\n",
    "# Тест 3: вектор (1, 2, 3, 4, 5, 6, 7, 8, 9) имеет L2-норму sqrt(285).\n",
    "vector3 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
    "assert l2_norm(vector3) == np.sqrt(285)\n",
    "\n",
    "# Тест 3: вектор (0, 0, 1) имеет L2-норму 1.\n",
    "vector3 = np.array([0, 0, 1])\n",
    "assert l2_norm(vector3) == 1.0\n",
    "\n",
    "# Тест 4: вектор (3, 4) имеет L2-норму 5.\n",
    "vector4 = np.array([3, 4])\n",
    "assert l2_norm(vector4) == 5.0\n",
    "\n",
    "# Тест 5: вектор (-3, -4) имеет L2-норму 5.\n",
    "vector5 = np.array([-3, -4])\n",
    "assert l2_norm(vector5) == 5.0\n",
    "\n",
    "# Тест 6: вектор (1, 1, 1) имеет L2-норму sqrt(3).\n",
    "vector6 = np.array([1, 1, 1])\n",
    "assert l2_norm(vector6) == np.sqrt(3)\n",
    "\n",
    "# Тест 7: вектор (0, 0, 0) имеет L2-норму 0.\n",
    "vector7 = np.array([0, 0, 0])\n",
    "assert l2_norm(vector7) == 0.0\n",
    "\n",
    "# Тест 8: вектор (1, 2, 3, 4, 5) имеет L2-норму sqrt(55).\n",
    "vector8 = np.array([1, 2, 3, 4, 5])\n",
    "assert l2_norm(vector8) == np.sqrt(55)\n",
    "\n",
    "# Тест 9: вектор (1, 2, 3, 4, 5, 6) имеет L2-норму sqrt(91).\n",
    "vector9 = np.array([1, 2, 3, 4, 5, 6])\n",
    "assert l2_norm(vector9) == np.sqrt(91)\n",
    "\n",
    "# Тест 10: вектор (1, 2, 3, 4, 5, 6, 7, 8, 9) имеет L2-норму sqrt(285).\n",
    "vector10 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
    "assert l2_norm(vector10) == np.sqrt(285)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "TF38RAXSzyp5",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-93859werh5c6cc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 2 (1 балл)**\n",
    "\n",
    "Напишите код функции, которая на вход принимает два одномерных np.array массива чисел и вычисляет их скалярное произведение с помощью NumPy. Если длины векторов не равны или векторы пустые, необходимо вернуть None."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "id": "zj7Mgw9Zzyp5",
    "nbgrader": {
     "grade": false,
     "grade_id": "scalar_product",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def scalar_product(arr1, arr2):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if (not arr1.size and not arr2.size) or (arr1.size != arr2.size):\n",
    "        return None\n",
    "\n",
    "    return np.dot(arr1, arr2)  \n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "id": "Fd7dhAbezyp5",
    "nbgrader": {
     "grade": true,
     "grade_id": "scalar_product_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "a = np.array([1, 2, 3])\n",
    "b = np.array([4, 5, 6])\n",
    "assert scalar_product(a, b) == 32\n",
    "\n",
    "a = np.array([1, 0, 0])\n",
    "b = np.array([0, 1, 0])\n",
    "assert scalar_product(a, b) == 0\n",
    "\n",
    "a = np.array([1, 2, 3, 4, 5])\n",
    "b = np.array([5, 4, 3, 2, 1])\n",
    "assert scalar_product(a, b) == 35\n",
    "\n",
    "a = np.array([1, 2])\n",
    "b = np.array([4, 5, 6])\n",
    "assert scalar_product(a, b) is None\n",
    "\n",
    "a = np.array([-1, 2, -3])\n",
    "b = np.array([4, -5, 6])\n",
    "assert scalar_product(a, b) == -32\n",
    "\n",
    "a = np.array([0, 0, 0])\n",
    "b = np.array([4, 5, 6])\n",
    "assert scalar_product(a, b) == 0\n",
    "\n",
    "a = np.array([1, 2, 3])\n",
    "b = np.array([4, 5])\n",
    "assert scalar_product(a, b) is None\n",
    "\n",
    "a = np.array([])\n",
    "b = np.array([4, 5, 6])\n",
    "assert scalar_product(a, b) is None\n",
    "\n",
    "a = np.array([])\n",
    "b = np.array([])\n",
    "assert scalar_product(a, b) is None\n",
    "\n",
    "a = np.array([1])\n",
    "b = np.array([4])\n",
    "assert scalar_product(a, b) == 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "Y8jxNxo4zyp5",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-938593csghcc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 3**\n",
    "\n",
    "Напишите код функции, которая на вход принимает два одномерных np.array массива чисел и вычисляет косинусное расстояние между ними с помощью NumPy. Если длины векторов не равны или один из векторов пустой, необходимо вернуть None. Если один из векторов нулевой, также нужно вернуть None."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "id": "-jbh2xgDzyp5",
    "nbgrader": {
     "grade": false,
     "grade_id": "cosine_distance",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def cosine_distance(arr1, arr2):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if (not arr1.size or not arr2.size) or (arr1.size != arr2.size):\n",
    "        return None\n",
    "\n",
    "    arr1_norm, arr2_norm = np.linalg.norm(arr1), np.linalg.norm(arr2)\n",
    "    \n",
    "    if arr1_norm == 0 or arr2_norm == 0:\n",
    "        return None\n",
    "\n",
    "    return 1 - np.dot(arr1, arr2) / (arr1_norm * arr2_norm)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "id": "3YMGPIJEzyp6",
    "nbgrader": {
     "grade": true,
     "grade_id": "cosine_distance_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "assert np.isclose(cosine_distance(np.array([1, 2, 3]), np.array([4, 5, 6])), 0.025368153802923787)\n",
    "assert cosine_distance(np.array([1, 2, 3]), np.array([4, 5])) is None\n",
    "assert cosine_distance(np.array([1, 2, 3]), np.array([])) is None\n",
    "assert np.isclose(cosine_distance(np.array([0, 1, 0, 1]), np.array([1, 0, 1, 0])), 1.0)\n",
    "assert np.isclose(cosine_distance(np.array([1, 0, 1]), np.array([-1, 0, -1])), 2.0)\n",
    "assert np.isclose(cosine_distance(np.array([3, 4]), np.array([6, 8])), 0.0)\n",
    "assert cosine_distance(np.array([]), np.array([1, 2, 3])) is None\n",
    "assert cosine_distance(np.array([]), np.array([])) is None\n",
    "assert cosine_distance(np.array([1, 2, 3]), np.array([0, 0, 0])) is None\n",
    "assert cosine_distance(np.array([0, 0, 0]), np.array([1, 2, 3])) is None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "MkAxuCVhzyp6",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-7f3c2292ajtt",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "# Часть 2. Матрицы. Сложение, умножение, определитель"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "FnizqfqHzyp6",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-938593c4a21sf5c6cc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 4**\n",
    "\n",
    "Напишите функцию, которая на вход принимает два np.array массива чисел и производит их поэлементное сложение с помощью NumPy. Если размеры матриц не совпадают или массивы пустые (не содержат элементов), вернуть None."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "id": "KnwCoGgazyp6",
    "nbgrader": {
     "grade": false,
     "grade_id": "add_arrays",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def is_empty(arr):\n",
    "    \"\"\"\n",
    "    Вспомогательная функция\n",
    "    Проверяет, является ли многомерный массив пустым.\n",
    "    \"\"\"\n",
    "    return arr.size == 0\n",
    "\n",
    "\n",
    "\n",
    "def add_arrays(arr1, arr2):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if (is_empty(arr1) or is_empty(arr2)) or arr1.size != arr2.size:\n",
    "        return None\n",
    "\n",
    "    return arr1 + arr2\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "id": "US7zEcWczyp6",
    "nbgrader": {
     "grade": true,
     "grade_id": "add_arrays_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "arr1 = np.array([1, 2, 3])\n",
    "arr2 = np.array([4, 5, 6])\n",
    "assert np.array_equal(add_arrays(arr1, arr2), np.array([5, 7, 9]))\n",
    "\n",
    "arr1 = np.array([1, 2, 3])\n",
    "arr2 = np.array([])\n",
    "assert add_arrays(arr1, arr2) is None\n",
    "\n",
    "arr1 = np.array([1.1, 2.2, 3.3])\n",
    "arr2 = np.array([4.4, 5.5, 6.6])\n",
    "assert np.allclose(add_arrays(arr1, arr2), np.array([5.5, 7.7, 9.9]))\n",
    "\n",
    "arr1 = np.array([1, 2, 3])\n",
    "arr2 = np.array([4, 5, 6])\n",
    "assert np.array_equal(add_arrays(arr1, arr2), add_arrays(arr2, arr1))\n",
    "\n",
    "arr1 = np.array([1, 2, 3])\n",
    "arr2 = np.array([4, 5, 6])\n",
    "arr3 = np.array([7, 8, 9])\n",
    "assert np.array_equal(add_arrays(add_arrays(arr1, arr2), arr3), add_arrays(arr1, add_arrays(arr2, arr3)))\n",
    "\n",
    "arr1 = np.array([1, 2, 3])\n",
    "arr2 = np.array([4, 5, 6])\n",
    "assert np.array_equal(add_arrays(arr1, arr2), add_arrays(arr1, arr2))\n",
    "\n",
    "arr1 = np.array([])\n",
    "arr2 = np.array([1, 2, 3])\n",
    "assert add_arrays(arr1, arr2) is None\n",
    "\n",
    "arr1 = np.array([])\n",
    "arr2 = np.array([[], []])\n",
    "assert add_arrays(arr1, arr2) is None\n",
    "\n",
    "arr1 = np.random.rand(1000)\n",
    "arr2 = np.random.rand(1000)\n",
    "assert np.allclose(add_arrays(arr1, arr2), arr1 + arr2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "x6YxXuX0zyp7",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-938593cdds5c6cc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 5**\n",
    "\n",
    "Напишите функцию, которая на вход принимает два np.array массива чисел и производит их умножение с помощью NumPy. Должны соблюдаться правила произведения матриц. Если правила не соблюдаются, функция должна вернуть None."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "id": "1RgNeF00zyp7",
    "nbgrader": {
     "grade": false,
     "grade_id": "matrix_multiply",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def matrix_multiply(a, b):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if a.ndim != 2 or b.ndim != 2:\n",
    "        return None\n",
    "    if a.shape[1] != b.shape[0]:\n",
    "        return None\n",
    "\n",
    "    return a.dot(b)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {
    "id": "BRx0TnRUzyp7",
    "nbgrader": {
     "grade": true,
     "grade_id": "matrix_multiply_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "a1 = np.array([[1, 2], [3, 4]])\n",
    "b1 = np.array([[5, 6], [7, 8]])\n",
    "c1 = np.array([[19, 22], [43, 50]])\n",
    "assert np.array_equal(matrix_multiply(a1, b1), c1)\n",
    "\n",
    "a2 = np.array([[1, 2, 3], [4, 5, 6]])\n",
    "b2 = np.array([[7, 8], [9, 10], [11, 12]])\n",
    "c2 = np.array([[58, 64], [139, 154]])\n",
    "assert np.array_equal(matrix_multiply(a2, b2), c2)\n",
    "\n",
    "a3 = np.array([[1, 2, 3], [4, 5, 6]])\n",
    "b3 = np.array([[7, 8], [9, 10]])\n",
    "assert matrix_multiply(a3, b3) is None\n",
    "\n",
    "a4 = np.array([1, 2, 3])\n",
    "b4 = np.array([4, 5, 6])\n",
    "assert matrix_multiply(a4, b4) is None\n",
    "\n",
    "a5 = np.array([[1, 2], [3, 4]])\n",
    "b5 = np.array([[5], [6]])\n",
    "c5 = np.array([[17], [39]])\n",
    "assert np.array_equal(matrix_multiply(a5, b5), c5)\n",
    "\n",
    "a6 = np.array([[1, 2, 3]])\n",
    "b6 = np.array([[4], [5], [6]])\n",
    "c6 = np.array([[32]])\n",
    "assert np.array_equal(matrix_multiply(a6, b6), c6)\n",
    "\n",
    "a7 = np.array([[]])\n",
    "b7 = np.array([[1]])\n",
    "assert matrix_multiply(a7, b7) is None\n",
    "\n",
    "a8 = np.array([[]])\n",
    "b8 = np.array([[]])\n",
    "assert matrix_multiply(a8, b8) is None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "llJ1NSJ2zyp7",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-938593cddehc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 6**\n",
    "\n",
    "Напишите функцию, которая на вход принимает np.array массив чисел и вычисляет определитель с помощью NumPy. Если матрица не квадратная, функция должна вернуть None."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {
    "id": "GUZ10bdtzyp7",
    "nbgrader": {
     "grade": false,
     "grade_id": "determinant",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def determinant(arr):\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if arr.ndim != 2:\n",
    "        return None\n",
    "    if arr.shape[0] != arr.shape[1]:\n",
    "        return None\n",
    "\n",
    "    return np.linalg.det(arr)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "id": "h2tcb1mvzyp7",
    "nbgrader": {
     "grade": true,
     "grade_id": "determinant_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "arr1 = np.array([[1, 2], [3, 4]])\n",
    "assert np.isclose(determinant(arr1), -2)\n",
    "\n",
    "arr2 = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n",
    "assert determinant(arr2) == None\n",
    "\n",
    "arr3 = np.array([[1]])\n",
    "assert np.isclose(determinant(arr3), 1)\n",
    "\n",
    "arr2 = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n",
    "assert np.isclose(determinant(arr2), 1)\n",
    "\n",
    "arr3 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n",
    "assert np.isclose(determinant(arr3), 0)\n",
    "\n",
    "arr5 = np.array([[1, 0], [0, 1], [0, 0]])\n",
    "assert determinant(arr5) == None\n",
    "\n",
    "arr6 = np.array([])\n",
    "assert determinant(arr6) == None\n",
    "\n",
    "arr8 = np.array([[1, 2], [3, 4], [5, 6]])\n",
    "assert determinant(arr8) == None\n",
    "\n",
    "arr9 = np.array([[1, 2, 3], [4, 5, 6]])\n",
    "assert determinant(arr9) == None\n",
    "\n",
    "arr10 = np.array([[1, 2], [3, 4], [5, 6]])\n",
    "assert determinant(arr10) == None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "TUGb3L7vzyp7",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-7d9f5sghj6f2b",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "# Часть 3. Производные, градиент"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "l6jc46gFzyp8",
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-9385sgj15c6cc",
     "locked": true,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "source": [
    "**Задание 7**\n",
    "\n",
    "Напишите функцию для вычисления производной функции $\\frac{7x^3}{3} - \\frac{5x^2}{2}$ в точке `x` при шаге дискретизации `d`. Функция должна возвращать переменную `df_dx`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {
    "id": "7L7Ok3OHzyp8",
    "nbgrader": {
     "grade": false,
     "grade_id": "calculate_dderivative",
     "locked": false,
     "schema_version": 3,
     "solution": true,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "df_dx = 0\n",
    "\n",
    "def f(x):\n",
    "    return 7*x**3/3 - 5*x**2/2\n",
    "\n",
    "def calculate_derivative(x, h=0.000001):\n",
    "    \"\"\"\n",
    "    Вычисляет производную \\frac{7x^3}{3} - \\frac{5x^2}{2} в точке x.\n",
    "\n",
    "    Аргументы:\n",
    "    f -- функция, производную которой требуется вычислить\n",
    "    x -- точка, в которой требуется вычислить производную, float\n",
    "    h -- шаг дискретизации, значение по умолчанию 0.000001, float\n",
    "    \"\"\"\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    df_dx = (f(x + h) - f(x)) / h\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ\n",
    "    return df_dx"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {
    "id": "QI5VieuOzyp8",
    "nbgrader": {
     "grade": true,
     "grade_id": "calculate_dderivative_test",
     "locked": true,
     "points": 1,
     "schema_version": 3,
     "solution": false,
     "task": false
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "assert np.isclose(calculate_derivative(0), 0, atol=0.1)\n",
    "assert np.isclose(calculate_derivative(1), 2, atol=0.1)\n",
    "assert np.isclose(calculate_derivative(2), 18, atol=0.1)\n",
    "assert np.isclose(calculate_derivative(3), 48, atol=0.1)\n",
    "assert np.isclose(calculate_derivative(5), 150, atol=0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "as-LmhVBbQcB"
   },
   "source": [
    "**Задание 8**\n",
    "\n",
    "Проверка признаков на коллинеарность.\n",
    "Даны значения двух признаков, X1 и X2.\n",
    "\n",
    "Проверьте, существует ли коллинеарность между этими признаками, вычислив коэффициент корреляции Пирсона между соответствующими векторами. Корреляция вычисляется как отношение коэффициента ковариации к произведению стандартных отклонений признаков.\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {
    "id": "MT0dEUShoH2s"
   },
   "outputs": [],
   "source": [
    "def calculate_correlation(X1, X2):\n",
    "    \"\"\"\n",
    "    Вычисляет коэффициент корелляции между двумя векторами X1, X2.\n",
    "\n",
    "    Аргументы:\n",
    "    X1 -- вектор значений признака 1.\n",
    "    X2 -- вектор значений признака 2.\n",
    "\n",
    "    Возвращает:\n",
    "    correlation -- коэффициент корреляции между векторами X1 и X2.\n",
    "    \"\"\"\n",
    "    # Вычислите средние значения для каждого признака, используя функцию np.mean\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    X1_mean = np.mean(X1)\n",
    "    X2_mean = np.mean(X2)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ\n",
    "\n",
    "    # Вычислите ковариацию между X1 и X2, используя функцию np.sum\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    covariance = np.sum((X1 - X1_mean) * (X2 - X2_mean)) / (len(X1) - 1)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ\n",
    "\n",
    "    # Вычислите стандартные отклонения X1 и X2, использая функции np.sqrt, np.sum\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    std_X1 = np.sqrt(np.sum((X1 - X1_mean)**2) / (len(X1) - 1))\n",
    "    std_X2 = np.sqrt(np.sum((X2 - X2_mean)**2) / (len(X2) - 1))\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ\n",
    "\n",
    "    # Вычислите коэффициент корреляции\n",
    "    # В случае, когда одно из отклонений равно нулю, код должен возвращать np.nan\n",
    "    #НАЧАЛО ВАШЕГО РЕШЕНИЯ\n",
    "    if std_X1 == 0 or std_X2 == 0:\n",
    "        return np.nan\n",
    "    else:\n",
    "        correlation = covariance / (std_X1 * std_X2)\n",
    "    #КОНЕЦ ВАШЕГО РЕШЕНИЯ\n",
    "\n",
    "    return correlation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {
    "id": "DUz-HFkBoG6P"
   },
   "outputs": [],
   "source": [
    "X1, X2 = [1, 2, 3, 4, 5], [2, 4, 6, 8, 10]\n",
    "assert np.isclose(calculate_correlation(X1, X2), 1, atol=0.1)\n",
    "X1, X2 = [-1, -2, -3, -4, -5], [2, 4, 6, 8, 10]\n",
    "assert np.isclose(calculate_correlation(X1, X2), -1, atol=0.1)\n",
    "X1, X2 = [1, 2, 3, 4, 5], [10, 8, 6, 4, 2]\n",
    "assert np.isclose(calculate_correlation(X1, X2), -1, atol=0.1)\n",
    "X1, X2 = [-1, 3, -5, 7, 9], [1, -3, 5, -7, 9]\n",
    "assert np.isclose(calculate_correlation(X1, X2), -0.11, atol=0.1)\n",
    "X1, X2 = [1, 1, 1, 1, 1], [2, 2, 2, 2, 2]\n",
    "assert np.isnan(calculate_correlation(X1, X2))"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
